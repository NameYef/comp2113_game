#include "player.h"
#include <iostream>
#include <string>
#include <random>
using namespace std;

// set the board to certain state to represent the location of ships
void Player::state_set(char& direction, int& head_x, int& head_y, int& no_of_blocks, int state_no) {
    int tail;
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x][head_y + i] != 2) {
                state[head_x][head_y + i] = state_no;
            }
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x + i][head_y] != 2) {
            state[head_x + i][head_y] = state_no;
            }
        }
    }
}

//check if coordinates randomly generated by bot_attack function are overalapping
bool Player::bot_overlap(int x, int y){
	if ((state[x][y]==4) || (state[x][y]==5)){
		return true;
	}
	return false;
}

void Player::hit(int cursor_x, int cursor_y) {
    for (auto& i : ships) {
        for (vector<vector<int>>::iterator j = i.begin(); j != i.end(); j++) {
            if (((*j)[0] == cursor_x) && ((*j)[1] == cursor_y)) {
                i.erase(j);
                return;
            }
        }
    }
}

// check if the current ship location overlaps with already occupied slots, state 2 means occupied
bool Player::overlap(char& direction, int& head_x, int& head_y, int& no_of_blocks) {
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x][head_y + i] == 2) {
                return true;
            }
            
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x + i][head_y] == 2) {
                return true;
            }
        }
    }
    return false;
}

// add the coordinates to the ships vector for each ship
void Player::ship_set(char direction, int current_ship, int head_x, int head_y, int no_of_blocks) {
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
           ships[current_ship][i][0] = head_x;
           ships[current_ship][i][1] = head_y + i;
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
           ships[current_ship][i][0] = head_x + i;
           ships[current_ship][i][1] = head_y;
        }
    }

}


void Player::bot_at_0(mt19937& gen){
	uniform_int_distribution<> intd(0,size_of_board - 1);
        int check_x=intd(gen);
        int check_y=intd(gen);
        while(bot_overlap(check_x, check_y)){
                check_x=intd(gen);
                check_y=intd(gen);
        }
        if(state[check_x][check_y]==1){
                state[check_x][check_y]=4;
        }
        else if(state[check_x][check_y]==2){
                state[check_x][check_y]=5;
                hit(check_x,check_y);
                bot_attempts=4;
                coordinate_x=check_x;
                coordinate_y=check_y;
                original_x=check_x;
                original_y=check_y;
        }
}

void Player::bot_at_4(mt19937& gen){
		if(coordinate_x-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
			bot_at_3(gen);
			return;
		}
		else if(bot_overlap(coordinate_x-1, coordinate_y)){
                        bot_at_3(gen);
			return;
                }
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]==2)){
                        state[coordinate_x-1][coordinate_y]=5;
                        hit(coordinate_x-1,coordinate_y);
                        bot_attempts=-4;
                        coordinate_x=coordinate_x-1;
                }
                else{
                        state[coordinate_x-1][coordinate_y]=4;
                        bot_attempts=3;
                }
}

void Player::bot_at_3(mt19937& gen){
                if(coordinate_y-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_2(gen);
			return;
                }
                else if(bot_overlap(coordinate_x, coordinate_y-1)){
                        bot_at_2(gen);
			return;
                }
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]==2)){
                        state[coordinate_x][coordinate_y-1]=5;
                        bot_attempts=-3;
                        hit(coordinate_x,coordinate_y-1);
                        coordinate_y=coordinate_y-1;
                }
                else{
                        state[coordinate_x][coordinate_y-1]=4;
                        bot_attempts=2;
                }
}

void Player::bot_at_2(mt19937& gen){
                if(coordinate_x+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_1(gen);
                        return;
                }
                else if(bot_overlap(coordinate_x+1, coordinate_y)){
                        bot_at_1(gen);
			return;
                }
                else if((coordinate_x+1<=size_of_board-1)&&(state[coordinate_x+1][coordinate_y]==2)){
                        state[coordinate_x+1][coordinate_y]=5;
                        bot_attempts=-2;
                        hit(coordinate_x+1,coordinate_y);
                        coordinate_x=coordinate_x+1;
                }
                else{
                        state[coordinate_x+1][coordinate_y]=4;
                        bot_attempts=1;
                }
}

void Player::bot_at_1(mt19937& gen){
                if(coordinate_y+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_0(gen);
                        return;
                }
		else if(bot_overlap(coordinate_x, coordinate_y+1)){
			bot_at_0(gen);
			return;
                }
		else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]==2)){
                        state[coordinate_x][coordinate_y+1]=5;
                        bot_attempts=-1;
                        hit(coordinate_x,coordinate_y+1);
                        coordinate_y=coordinate_y+1;
                }
                else{
                        state[coordinate_x][coordinate_y+1]=4;
                        bot_attempts=0;
                }
}

void Player::bot_at_neg4(mt19937& gen){
                if(coordinate_x-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_3(gen);
			return;
                }
		else if(bot_overlap(coordinate_x-1, coordinate_y)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
			bot_at_3(gen);
			return;
		}
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]==2)){
                        state[coordinate_x-1][coordinate_y]=5;
                        hit(coordinate_x-1,coordinate_y);
                        coordinate_x=coordinate_x-1;
                }
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]!=2)){
                        bot_attempts=3;
                        state[coordinate_x-1][coordinate_y]=4;
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

void Player::bot_at_neg3(mt19937& gen){
                if(coordinate_y-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_2(gen);
                        return;
                }
		else if(bot_overlap(coordinate_x, coordinate_y-1)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_2(gen);
			return;
		}
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]==2)){
                        state[coordinate_x][coordinate_y-1]=5;
                                    hit(coordinate_x,coordinate_y-1);
                        coordinate_y=coordinate_y-1;
                }
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]!=2)){
                        bot_attempts=2;
                        state[coordinate_x][coordinate_y-1]=4;
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

void Player::bot_at_neg2(mt19937& gen){
                if(coordinate_x+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_1(gen);
                        return;
                }
		else if(bot_overlap(coordinate_x+1, coordinate_y)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_1(gen);
			return;
		}
		else if((coordinate_x+1<=size_of_board-1)&&(state[coordinate_x+1][coordinate_y]==2)){
                        state[coordinate_x+1][coordinate_y]=5;
                                    hit(coordinate_x+1,coordinate_y);
                        coordinate_x=coordinate_x+1;
                }
                else if((coordinate_x+1<=size_of_board - 1)&&(state[coordinate_x+1][coordinate_y]!=2)){
                        bot_attempts=1;
                        state[coordinate_x+1][coordinate_y]=4;
                                    coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

void Player::bot_at_neg1(mt19937& gen){
                if(coordinate_y+1>size_of_board - 1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_0(gen);
                        return;
                }
                else if(bot_overlap(coordinate_x, coordinate_y+1)){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_at_0(gen);
                        return;
                }
		else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]==2)){
                        state[coordinate_x][coordinate_y+1]=5;
                        hit(coordinate_x,coordinate_y+1);
                        coordinate_y=coordinate_y+1;
                }
                else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]!=2)){
                        bot_attempts=0;
                        state[coordinate_x][coordinate_y+1]=4;
                }
}

void Player::bot_attack(){
	random_device rd;
	mt19937 gen(rd());
	if(bot_attempts==0)
	{
		bot_at_0(gen);
	}
	else if(bot_attempts==4){
		bot_at_4(gen);
	}
	else if(bot_attempts==3){
		bot_at_3(gen);
	}
	else if(bot_attempts==2){
		bot_at_2(gen);
	}
	else if (bot_attempts==1){
		bot_at_1(gen);
	}
	else if(bot_attempts==-4){
		bot_at_neg4(gen);
	}
	else if(bot_attempts==-3){
		bot_at_neg3(gen);
        }
	else if(bot_attempts==-2){
		bot_at_neg2(gen);
        }
        else if(bot_attempts==-1){
		bot_at_neg1(gen);
        }
}

bool Player::setup() {

    // create new window for set up
    WINDOW* win = newwin(41, 83, 0, 0);
    WINDOW* instruction = newwin(10, 39, 15, 88);
    refresh();

    // variables only used in this method
    int current_ship = 0;
    char direction = 'v';
    int input;
    bool ship_set = false;

    // a while loop to place every ship
    while (current_ship < no_of_ships) {

        // getting the head coordinates of the ship
        int head_x = (size_of_board - 1) / 2;
        int head_y = (size_of_board - 1) / 2;

        // the size of the ship
        int no_of_blocks = ships[current_ship].capacity();

        // a flag to know whether the ship is sucessfully placed
        ship_set = false;

        // while loop to keep prompting the player to place the ship in a valid spot
        while (!ship_set) {
            refresh();
            box(instruction, 0, 0);
            mvwprintw(instruction, 2, 13, "Player set-up");
            mvwprintw(instruction, 4, 8, "Arrow keys to move ship");
            mvwprintw(instruction, 5, 9, "SPACE to rotate ship");
            mvwprintw(instruction, 6, 12, "ENTER to confirm");
            mvwprintw(instruction, 7, 8, "%d out of 6 ships placed", current_ship);
            wrefresh(instruction);

            // set the state to 3 for the ship location to let player see where the ship currently is
            this->state_set(direction, head_x, head_y, no_of_blocks, 3);

            // input to move the ship
            this->draw(win);
            input = getch();
            refresh();


            switch (input) {
                case KEY_UP:
                    // move the ship upward and change the state of board back to 1 for the current location
                    if (!(head_y - 1 < 0)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_y--;
                    }
                    break;
                case KEY_DOWN:
                    // move the ship down
                    if (!((head_y + no_of_blocks >= size_of_board && direction == 'v') || (head_y + 1 >= size_of_board && direction == 'h'))) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_y++;
                    }
                    break;
                case KEY_LEFT:
                    // move the ship left
                    if (!(head_x - 1 < 0)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_x--;
                    }
                    break;
                case KEY_RIGHT:
                    // move the ship right
                    if (!((head_x + no_of_blocks >= size_of_board && direction == 'h') || (head_x + 1 >= size_of_board && direction == 'v'))) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_x++;
                    }
                    break;
                case 32: // 32 means spacebar
                    // change rotation
                    if (!(head_x + no_of_blocks - 1 >= size_of_board || head_y + no_of_blocks - 1 >= size_of_board)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    direction = (direction == 'h') ? 'v' : 'h';
                    }
                    break;
                case '\n':  //'n' means enter key
                    // check valid or not, if valid then set state to 2 and store the coords and break this loop
                    if (!this->overlap(direction, head_x, head_y, no_of_blocks)) {
                        this->state_set(direction, head_x, head_y, no_of_blocks, 2);
                        this->ship_set(direction, current_ship, head_x, head_y, no_of_blocks);
                        
                        ship_set = true;
                        break;
                    }
                    else {
                        // mvprintw(25, 100, "Invalid move! Choose another position.");
                        break;
                    }
                case 27: // 27 means escape
                    if (this->confirmQuit()) {
                        werase(win);
                        wrefresh(win);
                        werase(instruction);
                        wrefresh(instruction);
                        clear();
                        move(0, 0);
                        refresh();
                        return true;
                    }
                    else {
                        break;
                    }       
            }
        }
        // move on to the next ship
        current_ship++;

    }

    //erase the window when finish set up
    werase(win);
    wrefresh(win);
    werase(instruction);
    wrefresh(instruction);
    delwin(win);
    delwin(instruction);
    clear();
    move(0, 0);
    // refresh();
    // printw("set up finished\n");
    refresh();
    return false;
}

