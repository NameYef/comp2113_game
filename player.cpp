#include "player.h"
#include <iostream>
#include <string>
#include <random>
using namespace std;

// set the board to certain state to represent the location of ships
void Player::state_set(char& direction, int& head_x, int& head_y, int& no_of_blocks, int state_no) {
    int tail;
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x][head_y + i] != 2) {
                state[head_x][head_y + i] = state_no;
            }
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x + i][head_y] != 2) {
            state[head_x + i][head_y] = state_no;
            }
        }
    }
}

//check if coordinates randomly generated by bot_attack function are overalapping with already attacked positions
//if state of the cell on the board is equal to 4, cell was attacked but turned to be empty
//if state of the cell on the board is equal to 5, cell was attacked and turned out to be occupied partially wiht the ship
bool Player::bot_overlap(int x, int y){
	if ((state[x][y]==4) || (state[x][y]==5)){
		return true;
	}
	return false;
}

//deletes a coordinate of the player's ship in that ship's array if this coordinate was succesfully attacked by the bot
//cursor_x and cursor_y are coordinates of the cell that was attacked by the bot and the attack was succesful
//because there was a part of the ship in that cell
void Player::hit(int cursor_x, int cursor_y) {
    for (auto& i : ships) {
        for (vector<vector<int>>::iterator j = i.begin(); j != i.end(); j++) {
            if (((*j)[0] == cursor_x) && ((*j)[1] == cursor_y)) {
                i.erase(j);
                return;
            }
        }
    }
}

// check if the current ship location overlaps with already occupied slots, state 2 means occupied
bool Player::overlap(char& direction, int& head_x, int& head_y, int& no_of_blocks) {
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x][head_y + i] == 2) {
                return true;
            }
            
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
            if (state[head_x + i][head_y] == 2) {
                return true;
            }
        }
    }
    return false;
}

// add the coordinates to the ships vector for each ship
void Player::ship_set(char direction, int current_ship, int head_x, int head_y, int no_of_blocks) {
    if (direction == 'v') {
        for (int i = 0; i < no_of_blocks; i++) {
           ships[current_ship][i][0] = head_x;
           ships[current_ship][i][1] = head_y + i;
        }
    }
    else if (direction == 'h') {
        for (int i = 0; i < no_of_blocks; i++) {
           ships[current_ship][i][0] = head_x + i;
           ships[current_ship][i][1] = head_y;
        }
    }

}

//bot hasn't found any attacked cells yet and generates random coordinate to attack cells
void Player::bot_attempts_0(mt19937& gen){
	uniform_int_distribution<> intd(0,size_of_board - 1);
        int check_x=intd(gen);
        int check_y=intd(gen);
	//if coordinate was already attacked before so newly generated and old coordinates overlap, 
	//bot will continue to randomly generate coordinates until will find not overlapping coordinates
        while(bot_overlap(check_x, check_y)){
                check_x=intd(gen);
                check_y=intd(gen);
        }
	//if randomly generated coordinate was not revealed before and is empty, we change coordinate's state to revealed and empty (4)
        if(state[check_x][check_y]==1){
                state[check_x][check_y]=4;
        }
	//if coordinate was not revealed and is occupied, we change state of coordinate to revelaed and attacked (5)
        else if(state[check_x][check_y]==2){
                state[check_x][check_y]=5;
		//delete that coordinate from the corresponding ship array
                hit(check_x,check_y);
		//since bot_attempts=4, bot will start checking surrounding cells on whether they are also occupied on next function call
                bot_attempts=4;
		//save coordinates of attacked cell in coordinate_x and coordinate_y
                coordinate_x=check_x;
                coordinate_y=check_y;
		//save intial coordinates of attacked cell in coordinate_x and coordinate_y
		//will need this later since values of coordinate_x and coordinate_y will change and they will no longer store original coordinates of attacked cell
                original_x=check_x;
        }
}

//bot has found attacked cell and attacks cell to the left of it
void Player::bot_attempts_4(mt19937& gen){
		//check if coordinate is within the board, if not check next location - the upper cell
		//bot_attempts_3 is called in this case
		if(coordinate_x-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
			bot_attempts_3(gen);
			return;
		}
		//check if coordinate was already attacked before
		//if yes, check next location
		else if(bot_overlap(coordinate_x-1, coordinate_y)){
                        bot_attempts_3(gen);
			return;
                }
		//coordinate is occupied with part of the ship
		//change state to 5 (revealed and attacked)
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]==2)){
                        state[coordinate_x-1][coordinate_y]=5;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x-1,coordinate_y);
			//bot_attempts is (-4) now so bot will continue attacking cells in left direction on the next bot attack (function call)
                        bot_attempts=-4;
			//bot will attack cell to the left of occupied one on the next bot attack
                        coordinate_x=coordinate_x-1;
                }
		//coordinate is not occupied with ship
		//change state to 4 (revealed and empty)
                else{
                        state[coordinate_x-1][coordinate_y]=4;
			//bot attempts is 3 now so bot will check next location on the next bot attack
                        bot_attempts=3;
                }
}

//bot has found attacked cell and attacks cell above the found one to check whether it is occupied as well
void Player::bot_attempts_3(mt19937& gen){
		//check if coordinate is within the board, if not check next location - cell to the right of occupied one
                //bot_attempts_2 is called in this case
                if(coordinate_y-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_2(gen);
			return;
                }
		//check if coordinate was already attacked before
                //if yes, check next location
                else if(bot_overlap(coordinate_x, coordinate_y-1)){
                        bot_attempts_2(gen);
			return;
                }
		//coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]==2)){
                        state[coordinate_x][coordinate_y-1]=5;
			//bot_attempts is (-3) now so bot will continue attacking cells in upper direction on the next bot attack (function call)
                        bot_attempts=-3;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x,coordinate_y-1);
			//bot will attack cell above of occupied one on the next bot attack
                        coordinate_y=coordinate_y-1;
                }
		//coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else{
                        state[coordinate_x][coordinate_y-1]=4;
			//bot attempts is 2 now so bot will check next location on the next bot attack
                        bot_attempts=2;
                }
}

//bot has found attacked cell and attacks cell to the right of the found one to check whether it is occupied as well
void Player::bot_attempts_2(mt19937& gen){
		//check if coordinate is within the board, if not check next location - cell 1 cell lower the occupied one
                //bot_attempts_1 is called in this case
                if(coordinate_x+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_1(gen);
                        return;
                }
		//check if coordinate was already attacked before
                //if yes, check next location
                else if(bot_overlap(coordinate_x+1, coordinate_y)){
                        bot_attempts_1(gen);
			return;
                }
		//coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
                else if((coordinate_x+1<=size_of_board-1)&&(state[coordinate_x+1][coordinate_y]==2)){
                        state[coordinate_x+1][coordinate_y]=5;
			//bot_attempts is (-2) now so bot will continue attacking cells in right direction on the next bot attack (function call)
                        bot_attempts=-2;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x+1,coordinate_y);
			//bot will attack cell to the right of occupied one on the next bot attack
                        coordinate_x=coordinate_x+1;
                }
		//coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else{
                        state[coordinate_x+1][coordinate_y]=4;
			//bot attempts is 1 now so bot will check next location on the next bot attack
                        bot_attempts=1;
                }
}

//bot has found attacked cell and attacks cell 1 cell lower the found one to check whether it is occupied as well
void Player::bot_attempts_1(mt19937& gen){
		//check if coordinate is within the board, if not check the randomly generated coordinate since all locations have already been checked
		//meaning that there are no more occupied cells in the surroudings anymore
                //bot_attempts_0 is called in this case
                if(coordinate_y+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_0(gen);
                        return;
                }
		//check if coordinate was already attacked before
                //if yes, check the randomly generated coordinate since all locations have already been checked
                //meaning that there are no more occupied cells in the surroudings anymore
                //bot_attempts_0 is called in this case
		else if(bot_overlap(coordinate_x, coordinate_y+1)){
			bot_attempts_0(gen);
			return;
                }
		//coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
		else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]==2)){
                        state[coordinate_x][coordinate_y+1]=5;
			//bot_attempts is (-1) now so bot will continue attacking cells in lower direction on the next bot attack (function call)
                        bot_attempts=-1;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x,coordinate_y+1);
			//bot will attack cell lower of occupied one on the next bot attack
                        coordinate_y=coordinate_y+1;
                }
		//coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else{
                        state[coordinate_x][coordinate_y+1]=4;
			//bot attempts is 0 now so bot will check randomly generated coordinates on the next bot attack
                        bot_attempts=0;
                }
}

//bot has found that cell to the left of originally attacked one is also occupied so it starts attacking other cells in left direction
//to eliminate remaining part of the ship in this direction
void Player::bot_attempts_neg4(mt19937& gen){
		//check if coordinate is within the board, if not stop checking coordinates in this direction and check next location - the upper cell
		//checking is done based on coordinate_x and coordinate_y
		//to check next location - the cell above originally attacked cell, we need to return original coordinates to coordinate_x and coordinate_y in case their values were modified
                //bot_attempts_3 is called in this case
		if(coordinate_x-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_3(gen);
			return;
                }
		//check if coordinate was already attacked before
                //if yes, check next location
		//same condition with original coordinates as in previous if statement
		else if(bot_overlap(coordinate_x-1, coordinate_y)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
			bot_attempts_3(gen);
			return;
		}
                //coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]==2)){
                        state[coordinate_x-1][coordinate_y]=5;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x-1,coordinate_y);
			//bot will attack cell to the left of occupied one on the next bot attack
                        coordinate_x=coordinate_x-1;
                }
		//coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else if((coordinate_x-1>=0)&&(state[coordinate_x-1][coordinate_y]!=2)){
			//bot attempts is 3 now so bot will check next location on the next bot attack
                        bot_attempts=3;
                        state[coordinate_x-1][coordinate_y]=4;
			//same condition with original coordinates as stated before
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

//bot has found that cell above of originally attacked one is also occupied so it starts attacking other cells in that direction
//to eliminate remaining part of the ship in this direction
void Player::bot_attempts_neg3(mt19937& gen){
                //check if coordinate is within the board, if not stop checking coordinates in this direction and check next location - the right direction
                //checking is done based on coordinate_x and coordinate_y
                //to check next location - the cell right to the originally attacked cell, we need to return original coordinates to coordinate_x and coordinate_y in case their values were modified
                //bot_attempts_2 is called in this case
                if(coordinate_y-1<0){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_2(gen);
                        return;
                }
                //check if coordinate was already attacked before
                //if yes, check next location
                //same condition with original coordinates as in previous if statement
		else if(bot_overlap(coordinate_x, coordinate_y-1)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_2(gen);
			return;
		}
		//coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]==2)){
                        state[coordinate_x][coordinate_y-1]=5;
                        //delete that coordinate from the corresponding ships's array
                        hit(coordinate_x,coordinate_y-1);
                        //bot will attack cell above the occupied one on the next bot attack
                        coordinate_y=coordinate_y-1;
                }
                //coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else if((coordinate_y-1>=0)&&(state[coordinate_x][coordinate_y-1]!=2)){
			//bot attempts is 2 now so bot will check next location on the next bot attack
                        bot_attempts=2;
                        state[coordinate_x][coordinate_y-1]=4;
                        //same condition with original coordinates as stated before
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

//bot has found that cell to the right of originally attacked one is also occupied so it starts attacking other cells in right direction
//to eliminate remaining part of the ship in this direction
void Player::bot_attempts_neg2(mt19937& gen){
                //check if coordinate is within the board, if not stop checking coordinates in this direction and check next location - the lower direction
                //checking is done based on coordinate_x and coordinate_y
                //to check next location - the cell below the originally attacked cell, we need to return original coordinates to coordinate_x and coordinate_y in case their values were modified
                //bot_attempts_1 is called in this case
                if(coordinate_x+1>size_of_board-1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_1(gen);
                        return;
                }
                //check if coordinate was already attacked before
                //if yes, check next location
                //same condition with original coordinates as in previous if statement
		else if(bot_overlap(coordinate_x+1, coordinate_y)){
			coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_1(gen);
			return;
		}
                //coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
		else if((coordinate_x+1<=size_of_board-1)&&(state[coordinate_x+1][coordinate_y]==2)){
                        state[coordinate_x+1][coordinate_y]=5;
                        //delete that coordinate from the corresponding ships's array
                        hit(coordinate_x+1,coordinate_y);
                        //bot will attack cell to the right of the occupied one on the next bot attack
                        coordinate_x=coordinate_x+1;
                }
                //coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else if((coordinate_x+1<=size_of_board - 1)&&(state[coordinate_x+1][coordinate_y]!=2)){
                        //bot attempts is 1 now so bot will check next location on the next bot attack
                        bot_attempts=1;
                        state[coordinate_x+1][coordinate_y]=4;
			//same condition with original coordinates as stated before
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                }
}

//bot has found that cell below of originally attacked one is also occupied so it starts attacking other cells in that direction
//to eliminate remaining part of the ship in this direction
void Player::bot_attempts_neg1(mt19937& gen){
		//check if coordinate is within the board, if not stop checking coordinates in this direction and start checking random coordinates again on the next bot_attack
                //bot_attempts_0 is called in this case
                if(coordinate_y+1>size_of_board - 1){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_0(gen);
                        return;
                }
                //check if coordinate was already attacked before
                //if yes, stop checking this location and start checking random variables again on the next bot_attack
                else if(bot_overlap(coordinate_x, coordinate_y+1)){
                        coordinate_x=original_x;
                        coordinate_y=original_y;
                        bot_attempts_0(gen);
                        return;
                }
                //coordinate is occupied with part of the ship
                //change state to 5 (revealed and attacked)
		else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]==2)){
                        state[coordinate_x][coordinate_y+1]=5;
			//delete that coordinate from the corresponding ships's array
                        hit(coordinate_x,coordinate_y+1);
			//bot will attack cell below the occupied one on the next bot attack
                        coordinate_y=coordinate_y+1;
                }
		//coordinate is not occupied with ship
                //change state to 4 (revealed and empty)
                else if((coordinate_y+1<=size_of_board - 1)&&(state[coordinate_x][coordinate_y+1]!=2)){
			//bot_attempts is 0 now meaning that the bot will start checking random coordinates again on the next bot_attack
                        bot_attempts=0;
                        state[coordinate_x][coordinate_y+1]=4;
                }
}

//bot attacks different coordinates on the board
//meanigns of the states of the board's cells on coordinate x and y (i.e. state[x][y]=2):
// 2 - cell was not attacked before, thus it is unrevealed and occupied by a part of the ship
// 1 - cell was not attacked before, thus it is unrevealed and it is also empty
// 4 - cell was attacked before but turned to be empty
// 5 - cell was attacked before and turned to be occupied with part of the ship
// bot_attempts = 0 - bot has not found a cell with the ship yet and will attack random coordinate on the board
// for this, bot_attempts_0 is called
// bot_attempts = 4,3,2,1 - bot has found occupied cell and now checks surrounding cells on whether they are also occupied
// it is to ensure that bot will continue hitting the ship if it has hit it the first time
// bot_attempts = 4 - checking cell to the left from the attacked one
// bot_attempts = 3 - checking cell above the attacked one
// bot_attempts = 2 - checking cell to the right from the attacked one
// bot_attmpets = 1 - checking cell 1 cell lower from the attacked one
// bot_attempts = -4 - cell to the left from the attacked one was also occupied, so bot has to continue hitting cells in left direction
// bot_attmpets = -3 - cell above the attacked one was occupied so bot has to continue attacking cells above the attacked one
// bot_attempts = -2 - cell to the right from the attacked one was also occupied, so bot has to continue attacking cells in right direction
// bot_attempts = -1 - cell 1 cell down the attacked one was also occupied, so bot has tp continue attacking cells that are lower the attacked one

void Player::bot_attack(){
	random_device rd;
	mt19937 gen(rd());
	if(bot_attempts==0)
	{
		bot_attempts_0(gen);
	}
	else if(bot_attempts==4){
		bot_attempts_4(gen);
	}
	else if(bot_attempts==3){
		bot_attempts_3(gen);
	}
	else if(bot_attempts==2){
		bot_attempts_2(gen);
	}
	else if (bot_attempts==1){
		bot_attempts_1(gen);
	}
	else if(bot_attempts==-4){
		bot_attempts_neg4(gen);
	}
	else if(bot_attempts==-3){
		bot_attempts_neg3(gen);
        }
	else if(bot_attempts==-2){
		bot_attempts_neg2(gen);
        }
        else if(bot_attempts==-1){
		bot_attempts_neg1(gen);
        }
}

bool Player::setup() {

    // create new window for set up
    WINDOW* win = newwin(41, 83, 0, 0);
    WINDOW* instruction = newwin(10, 39, 15, 88);
    refresh();

    // variables only used in this method
    int current_ship = 0;
    char direction = 'v';
    int input;
    bool ship_set = false;

    // a while loop to place every ship
    while (current_ship < no_of_ships) {

        // getting the head coordinates of the ship
        int head_x = (size_of_board - 1) / 2;
        int head_y = (size_of_board - 1) / 2;

        // the size of the ship
        int no_of_blocks = ships[current_ship].capacity();

        // a flag to know whether the ship is sucessfully placed
        ship_set = false;

        // while loop to keep prompting the player to place the ship in a valid spot
        while (!ship_set) {
            refresh();
            box(instruction, 0, 0);
            mvwprintw(instruction, 2, 13, "Player set-up");
            mvwprintw(instruction, 4, 8, "Arrow keys to move ship");
            mvwprintw(instruction, 5, 9, "SPACE to rotate ship");
            mvwprintw(instruction, 6, 12, "ENTER to confirm");
            mvwprintw(instruction, 7, 8, "%d out of 6 ships placed", current_ship);
            wrefresh(instruction);

            // set the state to 3 for the ship location to let player see where the ship currently is
            this->state_set(direction, head_x, head_y, no_of_blocks, 3);

            // input to move the ship
            this->draw(win);
            input = getch();
            refresh();


            switch (input) {
                case KEY_UP:
                    // move the ship upward and change the state of board back to 1 for the current location
                    if (!(head_y - 1 < 0)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_y--;
                    }
                    break;
                case KEY_DOWN:
                    // move the ship down
                    if (!((head_y + no_of_blocks >= size_of_board && direction == 'v') || (head_y + 1 >= size_of_board && direction == 'h'))) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_y++;
                    }
                    break;
                case KEY_LEFT:
                    // move the ship left
                    if (!(head_x - 1 < 0)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_x--;
                    }
                    break;
                case KEY_RIGHT:
                    // move the ship right
                    if (!((head_x + no_of_blocks >= size_of_board && direction == 'h') || (head_x + 1 >= size_of_board && direction == 'v'))) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    head_x++;
                    }
                    break;
                case 32: // 32 means spacebar
                    // change rotation
                    if (!(head_x + no_of_blocks - 1 >= size_of_board || head_y + no_of_blocks - 1 >= size_of_board)) {
                    this->state_set(direction, head_x, head_y, no_of_blocks, 1);
                    direction = (direction == 'h') ? 'v' : 'h';
                    }
                    break;
                case '\n':  //'n' means enter key
                    // check valid or not, if valid then set state to 2 and store the coords and break this loop
                    if (!this->overlap(direction, head_x, head_y, no_of_blocks)) {
                        this->state_set(direction, head_x, head_y, no_of_blocks, 2);
                        this->ship_set(direction, current_ship, head_x, head_y, no_of_blocks);
                        
                        ship_set = true;
                        break;
                    }
                    else {
                        // mvprintw(25, 100, "Invalid move! Choose another position.");
                        break;
                    }
                case 27: // 27 means escape
                    if (this->confirmQuit()) {
                        werase(win);
                        wrefresh(win);
                        werase(instruction);
                        wrefresh(instruction);
                        clear();
                        move(0, 0);
                        refresh();
                        return true;
                    }
                    else {
                        break;
                    }       
            }
        }
        // move on to the next ship
        current_ship++;

    }

    //erase the window when finish set up
    werase(win);
    wrefresh(win);
    werase(instruction);
    wrefresh(instruction);
    delwin(win);
    delwin(instruction);
    clear();
    move(0, 0);
    // refresh();
    // printw("set up finished\n");
    refresh();
    return false;
}

